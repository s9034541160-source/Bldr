# Bldr Empire v2 - Unified Startup (PowerShell Version)
Write-Host "==================================================" -ForegroundColor Green
Write-Host "   Bldr Empire v2 - Unified Startup (PowerShell)" -ForegroundColor Green
Write-Host "==================================================" -ForegroundColor Green
Write-Host ""

# Change to project directory
Set-Location -Path $PSScriptRoot

# Kill any existing processes on our ports (EXCEPT Java/Neo4j)
Write-Host "[INFO] Cleaning up existing processes (excluding Neo4j and other Python apps)..." -ForegroundColor Cyan
taskkill /F /IM redis-server.exe 2>$null
taskkill /F /IM node.exe 2>$null
taskkill /F /IM uvicorn.exe 2>$null

# Don't kill all Python processes - only kill specific Bldr processes by port
$ports = @(8000, 3001)
foreach ($port in $ports) {
    $processes = netstat -ano | findstr ":$port"
    if ($processes) {
        $processes | ForEach-Object {
            if ($_ -match '\s+(\d+)$') {
                $processId = $matches[1]
                taskkill /F /PID $processId 2>$null
            }
        }
    }
}
taskkill /F /IM celery.exe 2>$null

Start-Sleep -Seconds 3

# Load environment variables
Write-Host "[INFO] Loading environment variables..." -ForegroundColor Cyan
if (Test-Path ".env") {
    Get-Content ".env" | Where-Object { $_ -notmatch '^\s*#' -and $_ -notmatch '^\s*$' } | ForEach-Object {
        $name, $value = $_.split('=', 2)
        if ($name -and $value) {
            [Environment]::SetEnvironmentVariable($name, $value, "Process")
            Set-Variable -Name $name -Value $value
        }
    }
    Write-Host "[INFO] Environment variables loaded from .env" -ForegroundColor Cyan
} else {
    Write-Host "[WARN] .env file not found, using default values" -ForegroundColor Yellow
    $env:NEO4J_USER = "neo4j"
    $env:NEO4J_PASSWORD = "neopassword"
    $env:REDIS_URL = "redis://localhost:6379"
    $env:NEO4J_URI = "neo4j://127.0.0.1:7687"
}

Write-Host "[INFO] Environment variables:" -ForegroundColor Cyan
Write-Host "  - NEO4J_USER: $($env:NEO4J_USER)" -ForegroundColor Cyan
Write-Host "  - NEO4J_PASSWORD: $($env:NEO4J_PASSWORD)" -ForegroundColor Cyan
Write-Host "  - NEO4J_URI: $($env:NEO4J_URI)" -ForegroundColor Cyan
Write-Host ""

# Check if Neo4j is running
Write-Host "[INFO] Checking Neo4j status..." -ForegroundColor Cyan
python check_neo4j_status.py
Write-Host ""

# 1. Start Redis
Write-Host "[INFO] Starting Redis server..." -ForegroundColor Cyan
if (Test-Path "redis") {
    Set-Location -Path "$PSScriptRoot\redis"
    if (Test-Path "redis-server.exe") {
        Start-Process -WindowStyle Minimized cmd "/c redis-server.exe redis.windows.conf"
        Write-Host "[INFO] Redis server started" -ForegroundColor Cyan
    } else {
        Write-Host "[ERROR] Redis server executable not found" -ForegroundColor Red
    }
    Set-Location -Path $PSScriptRoot
} else {
    Write-Host "[ERROR] Redis directory not found" -ForegroundColor Red
}
Start-Sleep -Seconds 5

# 2. Start Qdrant (if Docker is available)
Write-Host "[INFO] Starting Qdrant vector database..." -ForegroundColor Cyan
# If Qdrant already listening on 6333, skip Docker start and just report OK
$qdrantRunning = netstat -ano | findstr ":6333"
if ($qdrantRunning) {
    Write-Host "[INFO] Qdrant is already running on port 6333." -ForegroundColor Cyan
} else {
    $dockerBin = "docker"
    if (!(Get-Command docker -ErrorAction SilentlyContinue)) {
        if (Test-Path "${env:ProgramFiles}\Docker\Docker\resources\bin\docker.exe") {
            $dockerBin = "${env:ProgramFiles}\Docker\Docker\resources\bin\docker.exe"
        } elseif (Test-Path "${env:ProgramFiles}\Docker\Docker\resources\bin\com.docker.cli.exe") {
            $dockerBin = "${env:ProgramFiles}\Docker\Docker\resources\bin\com.docker.cli.exe"
        }
    }
    
    if (Get-Command $dockerBin -ErrorAction SilentlyContinue) {
        Write-Host "[INFO] Docker detected: $dockerBin" -ForegroundColor Cyan
        try {
            & $dockerBin version >$null 2>&1
            if ($LASTEXITCODE -eq 0) {
                & $dockerBin ps >$null 2>&1
                if ($LASTEXITCODE -ne 0) {
                    Write-Host "[WARN] Docker CLI available but daemon not reachable. Will try to start container anyway." -ForegroundColor Yellow
                }
                & $dockerBin start qdrant-bldr >$null 2>&1
                if ($LASTEXITCODE -ne 0) {
                    & $dockerBin run -d -p 6333:6333 -p 6334:6334 --name qdrant-bldr qdrant/qdrant:v1.7.0 >$null 2>&1
                    if ($LASTEXITCODE -ne 0) {
                        Write-Host "[WARN] Failed to start Qdrant container. System will use in-memory storage as fallback." -ForegroundColor Yellow
                    } else {
                        Write-Host "[INFO] Qdrant container created and started" -ForegroundColor Cyan
                    }
                } else {
                    Write-Host "[INFO] Qdrant container already running" -ForegroundColor Cyan
                }
            }
        } catch {
            Write-Host "[WARN] Docker not available. Qdrant will not be started." -ForegroundColor Yellow
            Write-Host "[INFO] System will use in-memory storage as fallback." -ForegroundColor Cyan
        }
    } else {
        Write-Host "[WARN] Docker not available. Qdrant will not be started." -ForegroundColor Yellow
        Write-Host "[INFO] System will use in-memory storage as fallback." -ForegroundColor Cyan
    }
}
Start-Sleep -Seconds 5

# 3. Start Celery worker and beat
Write-Host "[INFO] Starting Celery services..." -ForegroundColor Cyan
Set-Location -Path $PSScriptRoot
if (Test-Path "core") {
    Start-Process -WindowStyle Minimized cmd "/c celery -A core.celery_app worker --loglevel=info --concurrency=2"
    Start-Sleep -Seconds 2
    Start-Process -WindowStyle Minimized cmd "/c celery -A core.celery_app beat --loglevel=info"
    Write-Host "[INFO] Celery services started" -ForegroundColor Cyan
} else {
    Write-Host "[ERROR] Core directory not found" -ForegroundColor Red
}
Start-Sleep -Seconds 3

# 4. Start FastAPI backend
Write-Host "[INFO] Starting FastAPI backend..." -ForegroundColor Cyan
Set-Location -Path $PSScriptRoot

# Check for main.py in root directory first, then in backend directory
$mainPyPath = ""
if (Test-Path "main.py") {
    $mainPyPath = "main.py"
    Write-Host "[INFO] Found main.py in root directory" -ForegroundColor Cyan
} elseif (Test-Path "backend\main.py") {
    $mainPyPath = "backend\main.py"
    Write-Host "[INFO] Found main.py in backend directory" -ForegroundColor Cyan
} else {
    Write-Host "[ERROR] main.py not found in root or backend directory" -ForegroundColor Red
}

if ($mainPyPath -ne "") {
    # Extract the module path for uvicorn
    if ($mainPyPath -eq "main.py") {
        $modulePath = "main"
    } else {
        # Convert path to module format (backend\main.py -> backend.main)
        $modulePath = $mainPyPath -replace "\\", "." -replace "\.py$", ""
    }
    
    Write-Host "[INFO] Starting FastAPI with module: $modulePath" -ForegroundColor Cyan
    Start-Process cmd "/k python -m uvicorn $modulePath:app --host 127.0.0.1 --port 8000 --reload" -WindowStyle Normal
    Write-Host "[INFO] FastAPI backend started in visible window" -ForegroundColor Cyan
} else {
    Write-Host "[ERROR] Could not locate main.py - backend will not start" -ForegroundColor Red
}

Write-Host "[INFO] Waiting for backend to initialize..." -ForegroundColor Cyan
$backendReady = $false
$retryCount = 0
$maxRetries = 30  # Reduced timeout to 30 seconds
do {
    try {
        # Try /auth/debug endpoint first as it provides more detailed info about backend initialization
        $response = Invoke-WebRequest -Uri "http://localhost:8000/auth/debug" -Method GET -TimeoutSec 5
        if ($response.StatusCode -eq 200) {
            $backendReady = $true
            Write-Host "[INFO] Backend is ready" -ForegroundColor Cyan
            # Show some debug info
            try {
                $debugInfo = $response.Content | ConvertFrom-Json
                Write-Host "[INFO] Auth config: SKIP_AUTH=$($debugInfo.skip_auth), DEV_MODE=$($debugInfo.dev_mode)" -ForegroundColor Cyan
            } catch {
                # Ignore JSON parsing errors
            }
            break
        }
    } catch {
        try {
            # Fallback to /health endpoint
            $response = Invoke-WebRequest -Uri "http://localhost:8000/health" -Method GET -TimeoutSec 5
            if ($response.StatusCode -eq 200) {
                $backendReady = $true
                Write-Host "[INFO] Backend is ready (health check)" -ForegroundColor Cyan
                break
            }
        } catch {
            # Ignore errors and continue
        }
    }
    
    $retryCount++
    if ($retryCount % 5 -eq 0) {
        Write-Host "[INFO] Still waiting for backend... ($retryCount/30)" -ForegroundColor Yellow
    }
    Start-Sleep -Seconds 1
} while ($retryCount -lt $maxRetries)

if (-not $backendReady) {
    Write-Host "[ERROR] Backend failed to start in time" -ForegroundColor Red
    Write-Host "[WARN] Continuing startup anyway..." -ForegroundColor Yellow
}

#