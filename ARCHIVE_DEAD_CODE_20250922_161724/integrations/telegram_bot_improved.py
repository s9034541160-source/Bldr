#!/usr/bin/env python3
"""
Improved Telegram Bot for Bldr Empire v2
Fixed version with better error handling and user feedback
"""

import os
import base64
import logging
import requests
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Try to import Telegram libraries
try:
    from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardMarkup, KeyboardButton
    from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes, CallbackQueryHandler
    from telegram.constants import ChatAction
    TELEGRAM_AVAILABLE = True
except ImportError:
    print("Warning: Telegram libraries not available")
    TELEGRAM_AVAILABLE = False

# Configuration
TELEGRAM_BOT_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN', 'YOUR_TELEGRAM_BOT_TOKEN_HERE')
API_BASE = 'http://localhost:8000'
API_TOKEN = os.getenv('API_TOKEN')

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def get_auth_headers():
    """Get authentication headers for API calls"""
    headers = {"Content-Type": "application/json"}
    if API_TOKEN:
        headers['Authorization'] = f'Bearer {API_TOKEN}'
    return headers

async def handle_voice(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle voice messages with improved error handling"""
    if not TELEGRAM_AVAILABLE:
        return
    
    await update.message.reply_chat_action(ChatAction.TYPING)
    
    try:
        # Download voice file
        voice_file = await update.message.voice.get_file()
        voice_bytes = await voice_file.download_as_bytearray()
        voice_base64 = base64.b64encode(voice_bytes).decode('utf-8')
        
        await update.message.reply_text("üé§ –ü–æ–ª—É—á–∏–ª –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ. –¢—Ä–∞–Ω—Å–∫—Ä–∏–±–∏—Ä—É—é –∏ –∞–Ω–∞–ª–∏–∑–∏—Ä—É—é...")
        
        # Send to API
        headers = get_auth_headers()
        chat_payload = {
            'message': 'Voice message',
            'context_search': False,
            'max_context': 1,
            'agent_role': 'coordinator',
            'voice_data': voice_base64,
            'request_context': {
                'channel': 'telegram',
                'chat_id': update.message.chat_id,
                'user_id': update.message.from_user.id if update.message.from_user else None
            }
        }
        
        resp = requests.post(f'{API_BASE}/api/ai/chat', json=chat_payload, headers=headers, timeout=1800)
        
        if resp.status_code == 200:
            response_data = resp.json()
            ai_response = response_data.get('response', '')
            
            # Check for specific error messages
            if "Whisper not available" in ai_response:
                final_response = "üé§ –ì–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—É—á–µ–Ω–æ, –Ω–æ —Å–∏—Å—Ç–µ–º–∞ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è —Ä–µ—á–∏ –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞.\n\n–î–ª—è —Ä–∞–±–æ—Ç—ã —Å –≥–æ–ª–æ—Å–æ–≤—ã–º–∏ —Å–æ–æ–±—â–µ–Ω–∏—è–º–∏ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ Whisper:\n```bash\npip install openai-whisper\n```"
            elif "Audio transcription failed" in ai_response:
                final_response = "üé§ –ì–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—É—á–µ–Ω–æ, –Ω–æ –Ω–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å —Ä–µ—á—å.\n\n–í–æ–∑–º–æ–∂–Ω—ã–µ –ø—Ä–∏—á–∏–Ω—ã:\n‚Ä¢ –ù–∏–∑–∫–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ –∑–∞–ø–∏—Å–∏\n‚Ä¢ –°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ —à—É–º–∞\n‚Ä¢ –ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞\n\n–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ."
            else:
                final_response = f"üé§ –ì–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ:\n\n{ai_response}"
            
            await update.message.reply_text(final_response, parse_mode="Markdown")
        else:
            error_msg = resp.text if resp.text else f"HTTP {resp.status_code}"
            await update.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è: {error_msg}")
            
    except Exception as e:
        logger.error(f"Error processing voice message: {str(e)}")
        await update.message.reply_text(
            f"‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è: {str(e)}\n\n"
            "–í–æ–∑–º–æ–∂–Ω—ã–µ —Ä–µ—à–µ–Ω–∏—è:\n"
            "‚Ä¢ –ü—Ä–æ–≤–µ—Ä—å—Ç–µ, –∑–∞–ø—É—â–µ–Ω –ª–∏ API —Å–µ—Ä–≤–∏—Å\n"
            "‚Ä¢ –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏\n"
            "‚Ä¢ –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤–º–µ—Å—Ç–æ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ"
        )

async def handle_photo(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle photo messages with improved error handling"""
    if not TELEGRAM_AVAILABLE:
        return
    
    await update.message.reply_chat_action(ChatAction.TYPING)
    
    try:
        # Download photo
        photo = update.message.photo[-1]
        file = await photo.get_file()
        photo_bytes = await file.download_as_bytearray()
        photo_base64 = base64.b64encode(photo_bytes).decode('utf-8')
        
        # Get caption
        caption = update.message.caption or ""
        await update.message.reply_text("üì∏ –ü–æ–ª—É—á–∏–ª —Ñ–æ—Ç–æ. –ê–Ω–∞–ª–∏–∑–∏—Ä—É—é —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ...")
        
        # Prepare prompt
        if caption:
            prompt = f'–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π —ç—Ç–æ —Ñ–æ—Ç–æ —Å —É—á–µ—Ç–æ–º –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è: "{caption}". –ò–∑–≤–ª–µ–∫–∏ –∫–ª—é—á–µ–≤—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –∏ –Ω–∞–π–¥–∏ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–µ —Å—Ç—Ä–æ–∏—Ç–µ–ª—å–Ω—ã–µ –Ω–æ—Ä–º—ã.'
        else:
            prompt = '–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π —ç—Ç–æ —Ñ–æ—Ç–æ. –û–ø—Ä–µ–¥–µ–ª–∏ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–∏–≤–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã, –º–∞—Ç–µ—Ä–∏–∞–ª—ã, —Å–æ—Å—Ç–æ—è–Ω–∏–µ. –ü—Ä–æ–≤–µ—Ä—å —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ —Å—Ç—Ä–æ–∏—Ç–µ–ª—å–Ω—ã–º –Ω–æ—Ä–º–∞–º.'
        
        # Send to API
        headers = get_auth_headers()
        chat_payload = {
            'message': prompt,
            'context_search': True,
            'max_context': 3,
            'agent_role': 'coordinator',
            'image_data': photo_base64,
            'request_context': {
                'channel': 'telegram',
                'chat_id': update.message.chat_id,
                'user_id': update.message.from_user.id if update.message.from_user else None
            }
        }
        
        resp = requests.post(f'{API_BASE}/api/ai/chat', json=chat_payload, headers=headers, timeout=1800)
        
        if resp.status_code == 200:
            response_data = resp.json()
            ai_response = response_data.get('response', '')
            
            # Check for specific error messages
            if "–æ–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞" in ai_response:
                final_response = "üì∏ –§–æ—Ç–æ –ø–æ–ª—É—á–µ–Ω–æ, –Ω–æ —Å–∏—Å—Ç–µ–º–∞ –∞–Ω–∞–ª–∏–∑–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∞.\n\n–î–ª—è —Ä–∞–±–æ—Ç—ã —Å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è–º–∏ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏:\n```bash\npip install opencv-python pytesseract pillow\n```"
            elif "–û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è" in ai_response:
                final_response = "üì∏ –§–æ—Ç–æ –ø–æ–ª—É—á–µ–Ω–æ, –Ω–æ –Ω–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.\n\n–í–æ–∑–º–æ–∂–Ω—ã–µ –ø—Ä–∏—á–∏–Ω—ã:\n‚Ä¢ –ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞\n‚Ä¢ –ü–æ–≤—Ä–µ–∂–¥–µ–Ω–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ\n‚Ä¢ –û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏\n\n–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –¥—Ä—É–≥–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ."
            else:
                final_response = f"üì∏ –§–æ—Ç–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ:\n\n{ai_response}"
            
            await update.message.reply_text(final_response, parse_mode="Markdown")
        else:
            error_msg = resp.text if resp.text else f"HTTP {resp.status_code}"
            await update.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: {error_msg}")
            
    except Exception as e:
        logger.error(f"Error processing photo: {str(e)}")
        await update.message.reply_text(
            f"‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: {str(e)}\n\n"
            "–í–æ–∑–º–æ–∂–Ω—ã–µ —Ä–µ—à–µ–Ω–∏—è:\n"
            "‚Ä¢ –ü—Ä–æ–≤–µ—Ä—å—Ç–µ, –∑–∞–ø—É—â–µ–Ω –ª–∏ API —Å–µ—Ä–≤–∏—Å\n"
            "‚Ä¢ –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏\n"
            "‚Ä¢ –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –¥—Ä—É–≥–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ"
        )

# Rest of the bot implementation would go here...
# (Keeping it minimal for this example)

if __name__ == '__main__':
    if TELEGRAM_BOT_TOKEN == 'YOUR_TELEGRAM_BOT_TOKEN_HERE':
        print("Please set TELEGRAM_BOT_TOKEN environment variable")
        exit(1)
    
    print("Telegram bot improved version ready!")
    print("This is a fixed version with better error handling")