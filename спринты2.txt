
# План разработки BLDR.EMPIRE: Распределение задач по спринтам и промты для Cursor

## Общий подход к работе с Cursor

**Стратегия взаимодействия:**
1. Для каждой задачи использовать конкретный, детализированный промт с контекстом
2. При запросах к Cursor всегда указывать:
   - Текущий этап разработки
   - Требования к коду (паттерны, стандарты)
   - Интеграционные точки
   - Примеры из существующего кода (при наличии)
3. После генерации кода - запрашивать Unit-тесты для него
4. Использовать "контекстные файлы" в Cursor для поддержания целостности архитектуры

**Общий формат промтов для Cursor:**
```
<контекст проекта> + <конкретная задача> + <требования к реализации> + <примеры/аналоги> + <формат вывода>
```

---

## Спринт 1: Фундамент системы (2 недели)

### Задача 1.1: Настройка базовой архитектуры проекта

**Промт для Cursor:**
```
Я создаю новую версию приложения BLDR.EMPIRE - системы управления строительными проектами с использованием локальных ИИ-моделей.

Контекст:
- Это перезапуск проекта (была версия 0.6), но с нуля
- Архитектура: React + TypeScript для фронтенда, FastAPI + Python для бэкенда
- Используем Docker для контейнеризации
- Основной репозиторий: Bldr/

Задача:
Создай структуру проекта с разделением на слои:
1. Фронтенд: папка frontend/ с React + TypeScript + Ant Design
2. Бэкенд: папка backend/ с FastAPI + Python 3.10+
3. Общие модули: папка shared/ для типов и утилит
4. Docker: docker-compose.yml для локального запуска

Требования:
- Используй лучшие практики для React и FastAPI
- Добавь базовую конфигурацию TypeScript
- Настрой pyproject.toml для бэкенда
- Добавь .gitignore с правильными исключениями для node_modules и __pycache__
- Создай базовые файлы для CI/CD (GitHub Actions)

Вывод должен содержать:
- Древовидную структуру файлов
- Содержимое ключевых файлов конфигурации
- Комментарии в коде для ключевых решений
```

### Задача 1.2: Реализация модуля СОД (Среды Общих Данных)

**Промт для Cursor:**
```
Контекст:
- BLDR.EMPIRE требует единой Среды Общих Данных (СОД) для хранения всех документов
- Структура должна поддерживать версионирование, метаданные и права доступа
- Данные должны храниться в MinIO (S3-compatible) + PostgreSQL для метаданных
- Необходимо поддерживать типы документов: PDF, DOCX, XLSX, чертежи

Задача:
Создай модуль СОД для бэкенда с следующими функциями:
1. Загрузка файла с метаданными
2. Получение списка файлов по проекту
3. Получение конкретной версии файла
4. Поиск файлов по метаданным

Требования:
- Используй FastAPI для эндпоинтов
- Используй SQLAlchemy для работы с PostgreSQL
- Используй boto3 для работы с MinIO
- Реализуй схемы Pydantic для валидации данных
- Добавь базовую аутентификацию (JWT)
- Напиши документацию Swagger

Вывод должен содержать:
- Структуру папок для модуля СОД
- Содержимое основных файлов:
  * models.py (SQLAlchemy модели)
  * schemas.py (Pydantic схемы)
  * crud.py (операции с БД)
  * services/storage_service.py (работа с MinIO)
  * api/endpoints/documents.py (FastAPI роуты)
- Примеры запросов в документации
```

### Задача 1.3: Реализация RAG-пайплайна для базового модуля знаний

**Промт для Cursor:**
```
Контекст:
- BLDR.EMPIRE использует RAG как резервную/контрольную систему для основных дообученных LLM
- Необходимо реализовать базовый RAG-пайплайн для обработки строительных документов
- Документы включают: ГОСТы, СНиПы, СП, сметы, учебные материалы

Задача:
Создай RAG-модуль для бэкенда с функциями:
1. Индексация документов (PDF, DOCX, TXT)
2. Поиск релевантных фрагментов по запросу
3. Генерация ответов на основе найденных фрагментов

Требования:
- Используй llama-index для индексации
- Векторное хранилище: Qdrant (локальное развертывание)
- Эмбеддинги: sentence-transformers/all-mpnet-base-v2
- Разбивка на чанки: 1 пункт = 1 чанк, сохранение иерархии
- Обработка таблиц отдельно
- Добавь кэширование результатов

Вывод должен содержать:
- Структуру папок для RAG-модуля
- Содержимое основных файлов:
  * rag/indexer.py (индексация документов)
  * rag/retriever.py (поиск фрагментов)
  * rag/generator.py (генерация ответов)
  * config/rag_config.py (параметры конфигурации)
  * api/endpoints/rag.py (FastAPI эндпоинты)
- Примеры использования
- Unit-тесты для основных функций
```

### Задача 1.4: Базовый UI для управления проектами

**Промт для Cursor:**
```
Контекст:
- BLDR.EMPIRE - приложение для управления строительными проектами
- Фронтенд на React + TypeScript + Ant Design
- Необходим базовый UI с боковым меню, хедером и рабочей областью

Задача:
Создай базовую структуру UI с:
1. Боковым меню с пунктами: Проекты, Документы, ИИ-Ассистент, Обучение моделей
2. Хедером с поиском и уведомлениями
3. Основной рабочей областью с роутингом
4. Страницей списка проектов с таблицей
5. Страницей деталей проекта

Требования:
- Используй Ant Design компоненты
- Реализуй темизацию (светлая/темная)
- Добавь базовый роутинг с React Router
- Используй Redux Toolkit или Zustand для состояния
- Сделай адаптивную верстку
- Добавь хуки для API-запросов

Вывод должен содержать:
- Структуру папок для фронтенда
- Содержимое основных файлов:
  * layout/MainLayout.tsx (общий лейаут)
  * components/Sidebar.tsx (боковое меню)
  * components/Header.tsx (хедер)
  * pages/ProjectsPage.tsx (список проектов)
  * pages/ProjectDetailPage.tsx (детали проекта)
  * store/projectsSlice.ts (состояние для проектов)
  * services/api.ts (базовые API-запросы)
- Примеры использования компонентов
```

---

## Спринт 2: Ядро ИИ и критические процессы (3 недели)

### Задача 2.1: Интеграция локальных LLM моделей

**Промт для Cursor:**
```
Контекст:
- BLDR.EMPIRE использует локально развернутые GGUF-модели для обработки запросов
- Модели будут размещены в папке /models
- Необходимо реализовать управление моделями: загрузка, кэширование, выгрузка
- Система должна поддерживать одновременную работу с 2-3 моделями

Задача:
Создай модуль управления моделями для бэкенда:
1. Обнаружение доступных GGUF-моделей в файловой системе
2. Загрузка моделей в память с кэшированием
3. Управление ресурсами (автоматическая выгрузка неиспользуемых моделей)
4. Интерфейс для генерации текста и эмбеддингов

Требования:
- Используй llama-cpp-python для работы с GGUF
- Реализуй кэширование с TTL=5 минут и максимум 3 модели
- Добавь приоритет для координатора системы
- Реализуй асинхронную обработку запросов
- Добавь мониторинг использования памяти
- Учитывай ограничения GPU/CPU при загрузке

Вывод должен содержать:
- Структуру папок для модуля моделей
- Содержимое основных файлов:
  * core/model_manager.py (управление моделями)
  * services/llm_service.py (интерфейс для генерации)
  * config/model_config.py (параметры конфигурации)
  * utils/memory_monitor.py (мониторинг памяти)
  * api/endpoints/models.py (FastAPI эндпоинты)
- Примеры использования
- Unit-тесты для критических функций
```

### Задача 2.2: Модуль дообучения моделей через Unsloth

**Промт для Cursor:**
```
Контекст:
- BLDR.EMPIRE требует специализированного UI-модуля для дообучения локальных моделей
- Модуль должен быть доступен через отдельную вкладку в левом боковом меню
- Процесс дообучения включает: обработку PDF через OCR, создание Q-A пар, настройку параметров Unsloth

Задача:
Создай UI-модуль для дообучения моделей:
1. Страницу с формой для выбора файлов PDF
2. Интерфейс для DeepSeek-OCR (предпросмотр извлеченного текста)
3. Инструмент для генерации Q-A пар с возможностью редактирования
4. Форму настройки параметров Unsloth (базовая модель, эпохи, batch size)
5. Интерфейс мониторинга процесса обучения
6. Историю обученных моделей

Требования:
- Используй React + TypeScript + Ant Design
- Добавь drag-and-drop для загрузки файлов
- Реализуй preview для извлеченного текста
- Используй WebSocket для обновления статуса обучения
- Добавь визуализацию прогресса (графики, логи)
- Реализуй сохранение конфигураций обучения
- Сделай адаптивный дизайн

Вывод должен содержать:
- Структуру папок для модуля обучения
- Содержимое основных файлов:
  * pages/TrainingPage.tsx (основная страница)
  * components/DocumentUploader.tsx (загрузка файлов)
  * components/TextPreviewer.tsx (просмотр текста)
  * components/QAPairsGenerator.tsx (генерация Q-A пар)
  * components/TrainingConfigForm.tsx (настройка параметров)
  * components/TrainingMonitor.tsx (мониторинг)
  * services/trainingApi.ts (API для обучения)
- Примеры API-запросов к бэкенду
- Состояние в Redux/Zustand для управления процессом
```

### Задача 2.3: Backend для модуля дообучения

**Промт для Cursor:**
```
Контекст:
- Необходим backend для модуля дообучения моделей
- Должен интегрироваться с DeepSeek-OCR от Unsloth
- Процесс: обработка PDF → извлечение текста → создание Q-A пар → дообучение модели

Задача:
Создай бэкенд-модуль для дообучения:
1. Эндпоинт для обработки PDF через DeepSeek-OCR
2. Сервис для генерации Q-A пар из текста
3. Интеграция с Unsloth для дообучения GGUF-моделей
4. Менеджер задач обучения (очередь, статусы)
5. Хранение результатов обучения

Требования:
- Используй Celery + Redis для асинхронных задач
- Реализуй WebSocket эндпоинты для мониторинга прогресса
- Добавь валидацию входных данных
- Оптимизируй использование памяти при обработке больших PDF
- Реализуй логирование всех этапов
- Добавь возможность остановки обучения
- Сохраняй метрики качества модели

Вывод должен содержать:
- Структуру папок для модуля обучения
- Содержимое основных файлов:
  * services/ocr_service.py (интеграция с DeepSeek-OCR)
  * services/qa_generator.py (генерация Q-A пар)
  * services/training_service.py (дообучение через Unsloth)
  * tasks/training_tasks.py (асинхронные задачи Celery)
  * api/endpoints/training.py (FastAPI эндпоинты)
  * models/training.py (модели для БД)
- Примеры конфигурации Celery
- Схемы для WebSocket сообщений
```

### Задача 2.4: Автоматизация процесса F1.01 (Получение и анализ тендерной документации)

**Промт для Cursor:**
```
Контекст:
- Необходимо автоматизировать процесс F1.01 из ТЗ: анализ тендерной документации
- Процесс включает: получение заявки, анализ документации, создание карточки проекта
- Входные данные: email, Google Forms, Telegram, PDF/DOCX файлы
- Требуется интеграция с внешними сервисами

Задача:
Создай модуль для автоматизации F1.01:
1. Сервис обработки входящих заявок (email, Telegram, Google Forms)
2. OCR для извлечения текста из PDF/изображений
3. Анализ текста для создания карточки проекта
4. Интеграция с 1С для создания проекта
5. Уведомления ответственным менеджерам

Требования:
- Используй IMAP для обработки email
- Используй Telegram Bot API для приема заявок
- Используй Google Forms API для получения данных
- Используй Tesseract для OCR
- Реализуй обработку геоданных через Yandex Maps API
- Добавь автоматическое присвоение UUID проекта
- Интегрируй с 1С через REST API
- Добавь отслеживание SLA (1 час на создание карточки)

Вывод должен содержать:
- Структуру папок для модуля F1.01
- Содержимое основных файлов:
  * services/inbox_service.py (прием заявок)
  * services/ocr_service.py (обработка документов)
  * services/geo_service.py (геокодирование)
  * services/project_creator.py (создание карточки)
  * integrations/onec_integration.py (интеграция с 1С)
  * api/endpoints/inbox.py (эндпоинты)
  * models/project.py (модель данных проекта)
- Примеры конфигурации внешних сервисов
- Unit-тесты для основных функций
```

---

## Спринт 3: Специализированные модули и расширение функционала (3 недели)

### Задача 3.1: Модуль ЭДО (Электронный Документооборот)

**Промт для Cursor:**
```
Контекст:
- BLDR.EMPIRE требует модуля электронного документооборота
- Необходима поддержка согласования документов через BPMN-процессы
- Интеграция с КриптоПро для ЭЦП
- Интеграция с Диадок/СБИС для внешних документов
- Уведомления через Telegram и email

Задача:
Создай модуль ЭДО для системы:
1. Дизайнер BPMN-процессов согласования
2. Механизм маршрутизации документов
3. Интеграция с КриптоПро для наложения ЭЦП
4. Интеграция с Диадок API для внешних документов
5. Система уведомлений (Telegram Bot API, SendGrid)
6. Журнал согласований с аудитом

Требования:
- Используй Camunda BPMN для оркестрации процессов
- Реализуй адаптер для КриптоПро SDK
- Добавь интеграцию с Диадок API
- Используй WebSocket для реального времени обновлений
- Реализуй RBAC для доступа к документам
- Добавь версионирование документов
- Сделай мобильную версию для подписания в полевых условиях

Вывод должен содержать:
- Структуру папок для модуля ЭДО
- Содержимое основных файлов:
  * services/bpmn_orchestrator.py (управление процессами)
  * services/signature_service.py (работа с ЭЦП)
  * services/external_edo_service.py (интеграция с Диадок)
  * services/notification_service.py (уведомления)
  * api/endpoints/edo.py (эндпоинты)
  * models/document_flow.py (модели данных)
  * integrations/cryptopro_adapter.py (адаптер КриптоПро)
- Примеры BPMN-процессов для типовых согласований
- Unit-тесты для критических путей
```

### Задача 3.2: UI для ЭДО и документооборота

**Промт для Cursor:**
```
Контекст:
- Необходим UI для модуля ЭДО в BLDR.EMPIRE
- Интерфейс должен включать: список документов, детали документа, дизайнер BPMN
- Требуется мобильная версия для подписания в полевых условиях
- Интеграция с Telegram для уведомлений

Задача:
Создай UI-компоненты для модуля ЭДО:
1. Страницу списка исходящих/входящих документов
2. Страницу деталей документа с историей согласований
3. BPMN-редактор для создания маршрутов согласования
4. Модальное окно для наложения ЭЦП
5. Мобильное представление для подписания

Требования:
- Используй React + TypeScript + Ant Design
- Для BPMN-редактора используй react-bpmn
- Реализуй drag-and-drop для загрузки документов
- Добавь визуализацию маршрута согласования
- Сделай адаптивный дизайн для мобильных устройств
- Интегрируй с Telegram Web App для мобильного подписания
- Добавь анимации для улучшения UX
- Используй Redux Toolkit для управления состоянием

Вывод должен содержать:
- Структуру папок для UI ЭДО
- Содержимое основных файлов:
  * pages/EdoDocumentsPage.tsx (список документов)
  * pages/DocumentDetailPage.tsx (детали документа)
  * pages/BpmnDesignerPage.tsx (редактор BPMN)
  * components/DocumentCard.tsx (карточка документа)
  * components/ApprovalFlow.tsx (визуализация маршрута)
  * components/SignatureModal.tsx (модальное окно ЭЦП)
  * mobile/SignaturePage.tsx (мобильная версия)
  * services/edoApi.ts (API для ЭДО)
- Примеры использования BPMN-редактора
- Состояние Redux для управления документооборотом
```

### Задача 3.3: Интеграция с 1С (базовые API)

**Промт для Cursor:**
```
Контекст:
- BLDR.EMPIRE требует глубокой интеграции с 1С
- Необходимы интеграции с модулями: ДО, ЗУП, Бухгалтерия
- Требуется синхронизация данных в реальном времени
- Необходимо обрабатывать ошибки и повторные попытки

Задача:
Создай модуль интеграции с 1С:
1. Абстрактный адаптер для работы с 1С REST API
2. Конкретные сервисы для модулей 1С (ДО, ЗУП, Бухгалтерия)
3. Механизм повторных попыток и обработки ошибок
4. Кэширование данных для снижения нагрузки
5. Логирование всех запросов и ответов
6. Система вебхуков для обратной синхронизации

Требования:
- Используй паттерн адаптер для интеграции
- Реализуй retry-механизм с экспоненциальной задержкой
- Добавь rate limiting для защиты от перегрузки
- Используй асинхронные запросы
- Реализуй валидацию данных перед отправкой
- Добавь health-check для мониторинга доступности 1С
- Реализуй idempotency keys для идемпотентных операций
- Добавь документацию OpenAPI для всех эндпоинтов

Вывод должен содержать:
- Структуру папок для модуля интеграции
- Содержимое основных файлов:
  * integrations/onec/base_adapter.py (базовый адаптер)
  * integrations/onec/do_service.py (документооборот)
  * integrations/onec/zup_service.py (зарплата)
  * integrations/onec/accounting_service.py (бухгалтерия)
  * services/sync_service.py (синхронизация)
  * utils/retry_mechanism.py (механизм повторов)
  * config/onec_config.py (конфигурация)
- Примеры использования адаптеров
- Unit-тесты для обработки ошибок
```

### Задача 3.4: Telegram-бот для уведомлений и сбора данных

**Промт для Cursor:**
```
Контекст:
- BLDR.EMPIRE требует Telegram-бота для уведомлений и сбора данных
- Бот должен поддерживать: уведомления, опросы, прием фото/документов
- Необходима интеграция с основной системой через API
- Требуется аутентификация пользователей по Telegram ID

Задача:
Создай Telegram-бота для системы:
1. Аутентификация пользователей через Telegram ID
2. Система уведомлений о событиях в проектах
3. Опросы для сбора данных (инструктажи, подтверждения)
4. Прием фото и документов с объекта
5. Интеграция с основной системой через API
6. Админ-панель для управления ботом

Требования:
- Используй python-telegram-bot фреймворк
- Реализуй state machine для управления диалогами
- Добавь rate limiting для защиты от спама
- Используй Celery для асинхронной обработки
- Реализуй webhook для приема обновлений
- Добавь локализацию (русский/английский)
- Реализуй логирование всех действий
- Добавь health-check эндпоинт

Вывод должен содержать:
- Структуру папок для бота
- Содержимое основных файлов:
  * bot/main.py (точка входа)
  * bot/handlers/auth_handler.py (аутентификация)
  * bot/handlers/notification_handler.py (уведомления)
  * bot/handlers/poll_handler.py (опросы)
  * bot/handlers/document_handler.py (прием документов)
  * bot/services/api_service.py (интеграция с API)
  * bot/utils/state_manager.py (управление состоянием)
  * bot/config.py (конфигурация)
- Примеры диалогов с ботом
- Dockerfile для развертывания
- Unit-тесты для обработчиков
```

---

## Спринт 4: Оптимизация и подготовка к production (2 недели)

### Задача 4.1: Система мониторинга и логирования

**Промт для Cursor:**
```
Контекст:
- BLDR.EMPIRE требует комплексной системы мониторинга
- Необходимо отслеживать: производительность LLM, использование ресурсов, ошибки
- Требуется интеграция с Grafana/Prometheus для визуализации
- Логирование должно поддерживать структурированные логи

Задача:
Создай систему мониторинга и логирования:
1. Сбор метрик использования ресурсов
2. Трассировка запросов к LLM
3. Мониторинг ошибок и алертов
4. Интеграция с Prometheus/Grafana
5. Структурированное логирование в JSON
6. Dashboard в UI системы

Требования:
- Используй Prometheus client для сбора метрик
- Реализуй middleware для трассировки запросов
- Добавь алерты при превышении пороговых значений
- Используй Structlog для структурированного логирования
- Реализуй агрегацию логов в Elasticsearch
- Добавь визуализацию в Grafana
- Создай UI-компоненты для отображения метрик в админке
- Реализуй экспорт метрик в CSV/Excel

Вывод должен содержать:
- Структуру папок для мониторинга
- Содержимое основных файлов:
  * monitoring/metrics_collector.py (сбор метрик)
  * monitoring/tracing_middleware.py (трассировка)
  * monitoring/alert_manager.py (управление алертами)
  * logging/structured_logger.py (логирование)
  * integrations/prometheus_exporter.py (экспорт в Prometheus)
  * integrations/grafana_dashboard.py (конфигурация Grafana)
  * api/endpoints/monitoring.py (эндпоинты)
  * ui/components/MetricsDashboard.tsx (UI-компоненты)
- Примеры конфигурации Prometheus и Grafana
- Docker-compose для локального развертывания стека мониторинга
```

### Задача 4.2: Оптимизация производительности LLM

**Промт для Cursor:**
```
Контекст:
- BLDR.EMPIRE использует локальные LLM, которые могут быть ресурсоемкими
- Требуется оптимизация производительности для работы на оборудовании заказчика
- Необходимо реализовать кэширование, квантование, параллельную обработку

Задача:
Создай модуль оптимизации LLM:
1. Автоматическое квантование моделей (4-bit, 8-bit)
2. Система кэширования результатов
3. Параллельная обработка запросов
4. Балансировка нагрузки между моделями
5. Динамическое изменение параметров генерации
6. Мониторинг производительности и предложение оптимизаций

Требования:
- Используй bitsandbytes для квантования
- Реализуй LRU-кэш с TTL для результатов
- Добавь поддержку batching для параллельной обработки
- Используй asyncio для асинхронной обработки
- Реализуй динамическое регулирование max_tokens и temperature
- Добавь fallback-механизм при недостатке ресурсов
- Создай профайлер для выявления узких мест
- Реализуй автоматические рекомендации по оптимизации

Вывод должен содержать:
- Структуру папок для оптимизации
- Содержимое основных файлов:
  * optimization/quantizer.py (квантование моделей)
  * optimization/cache_manager.py (управление кэшем)
  * optimization/batch_processor.py (параллельная обработка)
  * optimization/load_balancer.py (балансировка нагрузки)
  * optimization/dynamic_params.py (динамические параметры)
  * optimization/profiler.py (профайлер производительности)
  * services/optimized_llm_service.py (оптимизированный сервис)
- Примеры конфигурации для разных типов оборудования
- Benchmarks до и после оптимизации
```

### Задача 4.3: CI/CD пайплайн и подготовка к production

**Промт для Cursor:**
```
Контекст:
- BLDR.EMPIRE готовится к production-развертыванию
- Требуется полноценный CI/CD пайплайн
- Необходимы автоматические тесты, сборка образов, деплой
- Требуется система отката при проблемах

Задача:
Создай CI/CD пайплайн для проекта:
1. Автоматический запуск unit и интеграционных тестов
2. Сборка Docker-образов для всех компонентов
3. Сканирование на уязвимости
4. Деплой в staging-среду
5. Ручное подтверждение для production
6. Автоматический откат при падении мониторинга
7. Генерация документации
8. Уведомления в Telegram/Slack о статусе

Требования:
- Используй GitHub Actions как CI/CD платформу
- Реализуй matrix testing для разных версий Python
- Добавь проверку кода статическими анализаторами (flake8, mypy)
- Используй Trivy для сканирования образов на уязвимости
- Реализуй blue/green deployment для zero-downtime
- Добавь health-check перед переключением трафика
- Реализуй систему feature flags для постепенного развертывания
- Добавь автоматическую генерацию changelog

Вывод должен содержать:
- Содержимое .github/workflows/:
  * test.yml (запуск тестов)
  * build.yml (сборка образов)
  * security.yml (безопасность)
  * staging.yml (деплой в staging)
  * production.yml (деплой в production)
- Dockerfile для всех компонентов с multi-stage сборкой
- docker-compose.production.yml для production
- Конфигурацию для Kubernetes (при необходимости)
- Скрипты для отката и восстановления
- Документацию по процессу деплоя
```

### Задача 4.4: Документация и финальная подготовка

**Промт для Cursor:**
```
Контекст:
- BLDR.EMPIRE готовится к передаче заказчику
- Требуется полная документация: техническая, пользовательская, процесс развертывания
- Необходимы скрипты для первоначальной настройки
- Требуется система лицензирования

Задача:
Создай полную документацию и скрипты для развертывания:
1. Техническую документацию архитектуры
2. Пользовательскую документацию
3. Инструкцию по развертыванию
4. Скрипты для инициализации БД и загрузки данных
5. Систему лицензирования (простую для MVP)
6. Скрипты для миграции данных из старой системы
7. Чек-лист приемки системы
8. Обучающие материалы для админов

Требования:
- Используй MkDocs для генерации документации
- Добавь диаграммы архитектуры (PlantUML)
- Реализуй простую систему лицензирования на основе JWT
- Создай скрипты инициализации для всех компонентов
- Добавь конфигурацию для разных окружений (dev, staging, prod)
- Реализуй скрипты резервного копирования
- Добавь примеры конфигурации для типовых сценариев
- Создай видео-инструкции для ключевых процессов

Вывод должен содержать:
- Структуру папки docs/ с полной документацией
- Содержимое scripts/ для развертывания и настройки:
  * init_db.py (инициализация БД)
  * load_initial_data.py (загрузка данных)
  * backup_system.sh (резервное копирование)
  * restore_system.sh (восстановление)
  * migrate_from_old_system.py (миграция)
- Реализацию системы лицензирования:
  * licensing/license_manager.py
  * api/endpoints/licensing.py
- Чек-лист приемки в формате Markdown
- Скрипты для генерации обучающих материалов
```

---

## Рекомендации по работе с Cursor

1. **Начинайте с архитектурного запроса:** Перед реализацией конкретной задачи сначала запросите рекомендации по архитектуре у Cursor:
   ```
   Я разрабатываю модуль для [название модуля] в системе управления строительными проектами. 
   Опиши оптимальную архитектуру для этого модуля с учетом следующих требований: [...]
   Предложи структуру файлов и основные компоненты.
   ```

2. **Используйте контекстные файлы:** Для сложных задач загружайте в контекст Cursor релевантные файлы из вашего проекта, особенно:
   - Конфигурационные файлы
   - Базовые абстракции
   - Примеры реализации похожих модулей

3. **Просите тесты отдельно:** После генерации основного кода всегда запрашивайте unit-тесты:
   ```
   Напиши unit-тесты для файла [путь к файлу], покрывающие основные сценарии использования и крайние случаи.
   Используй [pytest/unittest] и моки для внешних зависимостей.
   ```

4. **Итеративный подход:** Не пытайтесь получить идеальный код за один запрос. Используйте итеративный подход:
   - Сначала получите базовую реализацию
   - Затем запросите оптимизацию под конкретные требования
   - Наконец, попросите добавить обработку ошибок и edge cases

5. **Специфичные требования к коду:** Всегда указывайте конкретные требования к коду:
   ```
   При генерации кода следуй этим правилам:
   - Используй async/await для всех I/O операций
   - Добавляй типы TypeHints для всех функций
   - Используй логирование через logger.info/debug/warning вместо print
   - Добавляй docstrings в формате Google Style
   - Обрабатывай исключения и добавляй понятные сообщения об ошибках
   ```

Этот план обеспечит систематический подход к разработке BLDR.EMPIRE с использованием Cursor как основного инструмента для генерации кода.